# RS-Knight Stego: A Robust Image Steganography System

This project presents RS-Knight Stego, a robust image steganography system designed for secure and resilient data hiding. The system integrates **Reed-Solomon (RS) error correction codes** with a **Knight's Tour-based pixel selection algorithm** to embed data within digital images, ensuring both security and data integrity against noise.

## Overview

The core of this project is an advanced steganography technique that addresses the critical challenges of robustness and security in data hiding. The system leverages:

- **Reed-Solomon (RS) Codes**: Provides powerful error correction capabilities, allowing the embedded data to be recovered even when the steganographic image is corrupted by noise or minor modifications.
- **Knight's Tour Algorithm**: Generates a pseudo-random, non-repeating path for pixel selection during the embedding process. This enhances security by making the data's location statistically difficult to detect.
- **Dual-Layer LSB Embedding**: Utilizes both the Least Significant Bit (LSB) and the second LSB (LSB2) planes. Data is embedded in the LSB, while parity bits from the RS code are stored in the LSB2, effectively separating the payload from the error correction data.

This implementation is based on academic research and provides a complete framework, including data embedding, extraction, and a suite of analysis tools for evaluation.

## Features

### Core Functionality
- **Secure Data Embedding**: Hides text or binary data within lossless image formats (e.g., TIFF, PNG).
- **Error Correction & Recovery**: Reed-Solomon codes protect embedded data against transmission errors and noise.
- **Pseudo-Random Path Selection**: The Knight's Tour algorithm provides a complex and unpredictable embedding path.
- **Multi-format Support**: Optimized for lossless image formats to prevent data loss from compression.

### Analysis & Evaluation Tools
- **RS Steganalysis**: Detects potential steganographic content through statistical analysis of pixel relationships.
- **Chi-square Attack Simulation**: Implements chi-square steganalysis for security validation.
- **Oracle-Based Detector**: An advanced detection mechanism for evaluating the system's security threshold.
- **Image Quality Metrics**: Measures the visual impact of embedding using PSNR (Peak Signal-to-Noise Ratio) and SSIM (Structural Similarity Index).

## Installation

### Prerequisites
- Python 3.7 or higher
- `pip` package manager

### Setup
1. Clone the repository:
   ```bash
   git clone https://github.com/jack74387/RS-Knight-Stego.git
   cd RS-Knight-Stego
   ```

2. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

## Quick Start

### Basic Usage

#### Embedding Data
```python
from stegano.encoder import StegoEncoder

# Initialize the encoder with a seed for reproducible results
encoder = StegoEncoder(seed=123)

# Embed a secret message into an image
message = b"This is a secret message!"
encoder.encode_image(
    input_path="images/cover/4.1.01.tiff",
    output_path="output/stego_image.tiff", 
    data=message
)
```

#### Extracting Data
```python
from stegano.decoder import StegoDecoder

# Initialize the decoder with the same seed used for encoding
decoder = StegoDecoder(seed=123)

# Extract the hidden message from the stego image
recovered_data = decoder.decode_image("output/stego_image.tiff")
print("Recovered message:", recovered_data.decode('utf-8'))
```

### Advanced Examples

#### Noise Resilience Testing
This example demonstrates the system's ability to recover data from a corrupted image.
```python
from stegano.encoder import StegoEncoder
from stegano.decoder import StegoDecoder
from evaluation.visualizer import add_salt_pepper_noise
from PIL import Image
import numpy as np

# 1. Embed data
encoder = StegoEncoder(seed=42)
message = b"Testing error correction capabilities."
encoder.encode_image("images/cover/4.1.01.tiff", "output/stego_robustness_test.tiff", message)

# 2. Add salt-and-pepper noise to the stego image
stego_image = np.array(Image.open("output/stego_robustness_test.tiff"))
noisy_image = add_salt_pepper_noise(stego_image, amount=0.01)
Image.fromarray(noisy_image).save("output/stego_noisy.tiff")

# 3. Attempt to extract data from the noisy image
decoder = StegoDecoder(seed=42)
recovered = decoder.decode_image("output/stego_noisy.tiff")

# 4. Verify results
print("Original Message:", message.decode())
print("Recovered Message:", recovered.decode())
print("Recovery Successful:", message == recovered)
```

## Technical Details

### Algorithm Overview

This steganography method is designed in five main stages, providing a robust and secure embedding process:

1.  **Secret Message Pre-processing**
    -   **Length Marking**: The input secret message `M` is prefixed with a 3-byte header that specifies its total length in bytes. This ensures the decoder can accurately reconstruct the original message. The resulting message is `M' = Length(M) || M`.
    -   **Reed-Solomon Encoding**: To enhance error tolerance, the message `M'` is segmented and encoded using a **RS(255, 223)** encoder over the Galois Field GF(2⁸). Each 223-byte data segment is encoded into a 255-byte codeword, which can correct up to **16 symbol errors**. The final output is a single bitstream `BRS` ready for embedding.

2.  **Pixel Selection via Knight’s Tour**
    -   **Block Division**: The source image is divided into non-overlapping **16×16 blocks**. A unique Knight's Tour path is generated independently for each block.
    -   **Path Generation**: To ensure reproducibility, the path for each block is generated using a seed derived from its coordinates (`seed = r_block * W + c_block`). The path starts at the block's internal coordinate (0,0) and follows **Warnsdorff's rule**, a heuristic that efficiently generates a path covering all 256 pixels within the block.

3.  **Data Embedding Procedure**
    -   The bitstream `BRS` is embedded into the **four least significant bits (LSB1–LSB4)** of the RGB channels of each pixel.
    -   The embedding follows the Knight's Tour path. For each pixel, data is embedded sequentially across the RGB channels (R→G→B), and within each channel, across the bit planes (LSB1→LSB4).
    -   This non-continuous embedding across channels and bit planes enhances the spatial diffusion of the secret data, increasing resistance against statistical analysis.

4.  **Data Extraction and Decoding**
    -   **Path Reconstruction**: The stego image is divided into 16×16 blocks, and the same Knight's Tour path is reconstructed for each block using the same seeding mechanism.
    -   **Bit Extraction**: By traversing the path, the 4 LSBs are extracted from each RGB channel of every pixel using a bitmask (`0x0F`). These bits are concatenated to reconstruct the encoded bitstream `BRS`.
    -   **Reed-Solomon Decoding**: The bitstream `BRS` is segmented into 255-byte blocks, and the **RS(255, 223)** decoder is applied to correct errors and recover the original data stream `D`.

5.  **Message Reconstruction**
    -   The first **3 bytes** of the recovered data stream `D` are read to determine the original message length, `l`.
    -   The final secret message `M` is then extracted by slicing the subsequent `l` bytes from the stream (`M = D[3:3+l]`).

### Configuration Parameters

Key parameters of the system can be adjusted in `config.py`:

```python
# Reed-Solomon code parameters (default is n=7, k=4, nsym=3)
RS_N = 255  # Total codeword length for a different RS scheme
RS_K = 223  # Data portion length for a different RS scheme

# RS Steganalysis parameters
MASK_SIZE = (8, 8)    # Analysis window size
THRESHOLD = 0.1       # Detection sensitivity threshold
```

## Project Structure

```
RS-Knight-Stego/
├── stegano/              # Core steganography modules
│   ├── encoder.py        # Data embedding logic
│   ├── decoder.py        # Data extraction and recovery logic
│   ├── knight.py         # Knight's Tour path generation
│   ├── rs_coder.py       # Reed-Solomon encoding/decoding wrapper
│   └── utils.py          # Bit manipulation utilities
├── rs_analysis/          # Steganalysis tools
│   ├── rs_analyzer.py    # RS statistical analysis implementation
│   └── utils.py          # Helper functions for analysis
├── evaluation/           # Performance and quality evaluation tools
│   ├── metrics.py        # PSNR, SSIM, and other quality metrics
│   └── visualizer.py     # Noise simulation tools
├── examples/             # Usage examples and demonstrations
├── images/               # Sample cover and stego images
└── tests/                # Unit and integration tests
```

## Performance Characteristics

The system's performance is characterized by a trade-off between embedding capacity, visual quality, and robustness.

-   **Embedding Capacity**: The theoretical payload is approximately **0.375 bits per pixel (bpp)** for a 24-bit color image. The overhead from the RS(7,4) code is significant (3 parity bytes for every 4 data bytes) but is essential for robustness.
-   **Visual Quality**: Embedding typically results in a **PSNR value greater than 40 dB**, indicating that the visual distortion is minimal and generally imperceptible to the human eye.
-   **Error Correction Capability**: The RS(7,4) code can correct up to **1 byte of error** within each 7-byte codeword. This allows the system to withstand a salt-and-pepper noise level of approximately **1-2%** without data loss.

## Contributing

Contributions are welcome. Please follow these steps:

1. Fork the repository.
2. Create a feature branch (`git checkout -b feature/your-feature`).
3. Commit your changes (`git commit -m 'Add a new feature'`).
4. Push to the branch (`git push origin feature/your-feature`).
5. Open a Pull Request.

## Testing

To run the test suite (requires `pytest`):
```bash
python -m pytest tests/
```

To run a manual demonstration:
```bash
python examples/complete_demo.py
```

## Citation

If you use this code in your academic work or research, please cite it as follows:

```bibtex
@misc{rs-knight-stego,
  title={RS-Knight Stego: A Robust Image Steganography System with Reed-Solomon Error Correction},
  author={Chuang, Hsin-Min and Chao, Ching-Cheng},
  year={2024},
  publisher={GitHub},
  journal={GitHub repository},
  url={https://github.com/jack74387/RS-Knight-Stego}
}
```

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

## Acknowledgments

- The Reed-Solomon implementation is based on the `reedsolo` library.
- The steganalysis techniques are inspired by published academic research in the field.
